import 'package:lex/base/lexer.dart';
import 'package:lex/lexers/dart.dart';
import 'package:test/test.dart';

import 'regex_lexer_runner.dart';

class DartLexerRunner extends RegexLexerRunner {
  final lexer = DartLexer();
  final specs = {
    'final s = 1;': [
      const UnprocessedToken(0, Token.KeywordDeclaration, 'final'),
      const UnprocessedToken(5, Token.Text, ' '),
      const UnprocessedToken(6, Token.Name, 's'),
      const UnprocessedToken(7, Token.Text, ' '),
      const UnprocessedToken(8, Token.Operator, '='),
      const UnprocessedToken(9, Token.Text, ' '),
      const UnprocessedToken(10, Token.Number, '1'),
      const UnprocessedToken(11, Token.Punctuation, ';'),
    ],
    // Recursing same lexer to lex string interpolation
    "final s = '1 + 2 = \${(1 + 2 > 3) ? 3 : 1 + 2}';": [
      const UnprocessedToken(0, Token.KeywordDeclaration, 'final'),
      const UnprocessedToken(5, Token.Text, ' '),
      const UnprocessedToken(6, Token.Name, 's'),
      const UnprocessedToken(7, Token.Text, ' '),
      const UnprocessedToken(8, Token.Operator, '='),
      const UnprocessedToken(9, Token.Text, ' '),
      const UnprocessedToken(10, Token.StringSingle, '\''),
      const UnprocessedToken(11, Token.StringSingle, '1 + 2 = '),
      const UnprocessedToken(19, Token.StringInterpol, '\${'),
      const UnprocessedToken(0, Token.Punctuation, '('),
      const UnprocessedToken(1, Token.Number, '1'),
      const UnprocessedToken(2, Token.Text, ' '),
      const UnprocessedToken(3, Token.Operator, '+'),
      const UnprocessedToken(4, Token.Text, ' '),
      const UnprocessedToken(5, Token.Number, '2'),
      const UnprocessedToken(6, Token.Text, ' '),
      const UnprocessedToken(7, Token.Operator, '>'),
      const UnprocessedToken(8, Token.Text, ' '),
      const UnprocessedToken(9, Token.Number, '3'),
      const UnprocessedToken(10, Token.Punctuation, ')'),
      const UnprocessedToken(11, Token.Text, ' '),
      const UnprocessedToken(12, Token.Operator, '?'),
      const UnprocessedToken(13, Token.Text, ' '),
      const UnprocessedToken(14, Token.Number, '3'),
      const UnprocessedToken(15, Token.Text, ' '),
      const UnprocessedToken(16, Token.Operator, ':'),
      const UnprocessedToken(17, Token.Text, ' '),
      const UnprocessedToken(18, Token.Number, '1'),
      const UnprocessedToken(19, Token.Text, ' '),
      const UnprocessedToken(20, Token.Operator, '+'),
      const UnprocessedToken(21, Token.Text, ' '),
      const UnprocessedToken(22, Token.Number, '2'),
      const UnprocessedToken(44, Token.StringInterpol, '}'),
      const UnprocessedToken(45, Token.StringSingle, '\''),
      const UnprocessedToken(46, Token.Punctuation, ';'),
    ],
    'void foo(int a, String s = \'\') {'
        '  for (int i = 0; i < a; i++) {'
        '    s += i.toString();'
        '  }'
        '  return s;'
        '}': [
      const UnprocessedToken(0, Token.KeywordType, 'void'),
      const UnprocessedToken(4, Token.Text, ' '),
      const UnprocessedToken(5, Token.Name, 'foo'),
      const UnprocessedToken(8, Token.Punctuation, '('),
      const UnprocessedToken(9, Token.KeywordType, 'int'),
      const UnprocessedToken(12, Token.Text, ' '),
      const UnprocessedToken(13, Token.Name, 'a'),
      const UnprocessedToken(14, Token.Punctuation, ','),
      const UnprocessedToken(15, Token.Text, ' '),
      const UnprocessedToken(16, Token.KeywordType, 'String'),
      const UnprocessedToken(22, Token.Text, ' '),
      const UnprocessedToken(23, Token.Name, 's'),
      const UnprocessedToken(24, Token.Text, ' '),
      const UnprocessedToken(25, Token.Operator, '='),
      const UnprocessedToken(26, Token.Text, ' '),
      const UnprocessedToken(27, Token.StringSingle, '\''),
      const UnprocessedToken(28, Token.StringSingle, '\''),
      const UnprocessedToken(29, Token.Punctuation, ')'),
      const UnprocessedToken(30, Token.Text, ' '),
      const UnprocessedToken(31, Token.Punctuation, '{'),
      const UnprocessedToken(32, Token.Text, '  '),
      const UnprocessedToken(34, Token.Keyword, 'for'),
      const UnprocessedToken(37, Token.Text, ' '),
      const UnprocessedToken(38, Token.Punctuation, '('),
      const UnprocessedToken(39, Token.KeywordType, 'int'),
      const UnprocessedToken(42, Token.Text, ' '),
      const UnprocessedToken(43, Token.Name, 'i'),
      const UnprocessedToken(44, Token.Text, ' '),
      const UnprocessedToken(45, Token.Operator, '='),
      const UnprocessedToken(46, Token.Text, ' '),
      const UnprocessedToken(47, Token.Number, '0'),
      const UnprocessedToken(48, Token.Punctuation, ';'),
      const UnprocessedToken(49, Token.Text, ' '),
      const UnprocessedToken(50, Token.Name, 'i'),
      const UnprocessedToken(51, Token.Text, ' '),
      const UnprocessedToken(52, Token.Operator, '<'),
      const UnprocessedToken(53, Token.Text, ' '),
      const UnprocessedToken(54, Token.Name, 'a'),
      const UnprocessedToken(55, Token.Punctuation, ';'),
      const UnprocessedToken(56, Token.Text, ' '),
      const UnprocessedToken(57, Token.Name, 'i'),
      const UnprocessedToken(58, Token.Operator, '+'),
      const UnprocessedToken(59, Token.Operator, '+'),
      const UnprocessedToken(60, Token.Punctuation, ')'),
      const UnprocessedToken(61, Token.Text, ' '),
      const UnprocessedToken(62, Token.Punctuation, '{'),
      const UnprocessedToken(63, Token.Text, '    '),
      const UnprocessedToken(67, Token.Name, 's'),
      const UnprocessedToken(68, Token.Text, ' '),
      const UnprocessedToken(69, Token.Operator, '+'),
      const UnprocessedToken(70, Token.Operator, '='),
      const UnprocessedToken(71, Token.Text, ' '),
      const UnprocessedToken(72, Token.Name, 'i'),
      const UnprocessedToken(73, Token.Punctuation, '.'),
      const UnprocessedToken(74, Token.Name, 'toString'),
      const UnprocessedToken(82, Token.Punctuation, '('),
      const UnprocessedToken(83, Token.Punctuation, ')'),
      const UnprocessedToken(84, Token.Punctuation, ';'),
      const UnprocessedToken(85, Token.Text, '  '),
      const UnprocessedToken(87, Token.Punctuation, '}'),
      const UnprocessedToken(88, Token.Text, '  '),
      const UnprocessedToken(90, Token.Keyword, 'return'),
      const UnprocessedToken(96, Token.Text, ' '),
      const UnprocessedToken(97, Token.Name, 's'),
      const UnprocessedToken(98, Token.Punctuation, ';'),
      const UnprocessedToken(99, Token.Punctuation, '}'),
    ],
  };
}

void main() {
  group('Lexer: Dart', () {
    DartLexerRunner().run();
  });
}
